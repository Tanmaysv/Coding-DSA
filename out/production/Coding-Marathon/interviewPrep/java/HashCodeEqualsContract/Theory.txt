1)If two Objects are equal, according to the equals(Object) method,
then hashCode() method must produce the same Integer on each of the two Objects.


2)If two Objects are unequal, according to the equals(Object) method,
It is not necessary the Integer value produced by hashCode() method on each of
the two Objects will be distinct. It can be same but producing the distinct Integer on each of the
two Objects is better for improving the performance of hashing based Collections like HashMap, HashTableâ€¦etc.


3)internal consistency: the value of hashCode() may only change if a property that is in equals() changes


4)If we override equals(), we must also override hashCode().


You must override hashCode() in every class that overrides equals().
Failure to do so will result in a violation of the general contract
for Object.hashCode(), which will prevent your class from functioning
properly in conjunction with all hash-based collections, including HashMap, HashSet, and Hashtable.






Let's try to understand it with an example of what would happen if
 we override equals() without overriding hashCode() and attempt to use a Map.

Say we have a class like this and that two objects of MyClass are equal
if their importantField is equal (with hashCode() and equals() generated by eclipse)

public class MyClass {

    private final String importantField;
    private final String anotherField;

    public MyClass(final String equalField, final String anotherField) {
        this.importantField = equalField;
        this.anotherField = anotherField;
    }

    public String getEqualField() {
        return importantField;
    }

    public String getAnotherField() {
        return anotherField;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result
                + ((importantField == null) ? 0 : importantField.hashCode());
        return result;
    }

    @Override
    public boolean equals(final Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        final MyClass other = (MyClass) obj;
        if (importantField == null) {
            if (other.importantField != null)
                return false;
        } else if (!importantField.equals(other.importantField))
            return false;
        return true;
    }

}
Override only equals

If only equals is overriden, then when you call myMap.put(first,someValue)
first will hash to some bucket and when you call myMap.put(second,someOtherValue)
 it will hash to some other bucket (as they have a different hashCode). So, although
 they are equal, as they don't hash to the same bucket, the map can't realize it
  and both of them stay in the map.